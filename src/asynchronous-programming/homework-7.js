'use strict';

// Домашнє завдання по темі ‘Асинхронне програмування’

// --- TASK 1 --- //
// Яким буде результат його виклику? Чому? Опишіть як працює цей код.
console.log('start');

const promise1 = new Promise((resolve, reject) => {
console.log(1)
resolve(2)
})

promise1.then(res => {
console.log(res)
})

console.log('end');

// ==> Результат виклику буде наступний:
// "start"
// 1
// "end"
// 2

// ==> Чому код працює саме з таким результатом?
// 1) console.log('start') >>> Спочатку, ми отримаємо вивід у консоль строку 'start', так як інтерпрітатор JavaScript зчитує
// код зверху вниз і цей рядок коду в глобальній області видимості, з самого початку. 
// 2) const promise1 = new Promise() >>> Потім, створюється конструктор Promise, який приймає функцію з двома
// аргументами "resolve()" і "reject()", які є функціями зворотного виклику для вирішення або відхилення обіцянки. В данному випадку,
// у функції спочтаку спрацьовує виклик console.log(1), а потім resolve(2), що вказує на успішне виконання обіцянки з аргументом 2,
// що виводить як результат і це додається у чергу завдань для вирішення проміса. 
// 3) promise1.then(res => {}) >>> Викликається метод then() для обробки результату обіцянки в promise1. Коли виконується
// успішно обіцянка promise1, тоді переданий в колбек функцію параметр res приймає значення, що передане у resolve (тобто, це число 2). 
// 5) console.log('end') >>> Виводиться результат виклику console.log, отже строка 'end'. Але, так як в нашому випадку
// функція обіцянки є асинхронною, то вона виконується після всі інших рядків коду. Тому, спочатку отримаємо вивід 'end', потім число 2.





// --- TASK 2 --- //
// Яким буде результат його виклику? Чому? Опишіть як працює цей код.
Promise.resolve(1)
		.then((x) => x + 1)
		.then((x) => { throw new Error('My Error') })
		.catch(() => 1)
		.then((x) => x + 1)
		.then((x) => console.log(x))
		.catch(console.error)

// ==> Результат виклику буде наступний:
// 2

// ==> Чому код працює саме з таким результатом?
// 1) Promise.resolve(1) >>> Створуюється обʼєкт Promise з обіцянкою resolve(), що вказує на успішне її виконання з аргументом 2.
// 2) .then((x) => x + 1) >>> Потім викликається перший метод then() і передається в колбек функцію параметр x, який повертає x + 1. 
// Результат виконання буде 2.
// 3) .then((x) => { throw new Error('My Error') }) >>> Викликається настпуний метод then(), який показує помилку 
// з повідомленням 'My Error'.
// 4) .catch(() => 1) >>> Метод catch() оброблює попередню помилку і повертає значення 1 для обіцянки.
// 5) .then((x) => x + 1) >>> Натсупний рядок викликає знову методу then() і замість значення x буде 1, що повернуте 
// з попереднього виклику. Результат виконання буде 2.
// 6) .then((x) => console.log(x)) >>> В цьому випадку, значення х буде також 2, так як ми виводимо по суті в консоль 
// попередній виклик.
// 7) .catch(console.error) >>> Цей виклик методу не буде оброблюватись, бо ми вже успішно обробили помилку раніше






// --- TASK 3 --- //
// Яким буде результат його виклику? Чому? Опишіть як працює цей код.
const promise = new Promise(res => res(2));
	promise.then(v => {
	        console.log(v);
	        return v * 2;
	    })
	    .then(v => {
	        console.log(v);
	        return v * 2;
	    })
	    .finally(v => {
	        console.log(v);
	        return v * 2;
	    })
	    .then(v => {
	        console.log(v);
	    });

// ==> Результат виклику буде наступний:
// 4

// ==> Чому код працює саме з таким результатом?
// 1) const promise = new Promise(res => res(2)) >>> Створюємо об'єкт Promise, який відразу викликає функцію res з аргументом 2
// і виконує обіцянку
// 2) promise.then(v => {}) >>> Викликаємо метод .then() для асинхронної обробки результату обіцянки, яка була вже виконана.
// Консоль виводить 2, а потім повертаємо нове значення return v * 2 = 2 * 2, що = 4.
// 3) Виконується наступний then(), в которому консоль виводить 4(з попереднього then()), потім повертаємо нове значення 
// return v * 2 = 4 * 2, що = 8.
// 4) Виконується метод finally(), але незалежно від успіху або невдачі попередніх обробок, він не приймає аргументів і
// не оброблює попередні результати, які були при виклику then(). Отже, тут консоль виведе 2 і потім повертаємо нове значення
// return v * 2 = 2 * 2, що = 4.
// 5) Виконується метод then(), в якому виводимо в консоль резултат попереднього виклику then().